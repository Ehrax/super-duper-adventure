\documentclass{scrartcl}

\usepackage[ngerman]{babel}

\usepackage[utf8]{inputenc}
\usepackage{hyperref,xcolor,microtype,ifthen}
\usepackage{csquotes}
\usepackage{parskip}

\usepackage{graphicx}
\usepackage{svg}

\usepackage{helvet}
\renewcommand{\familydefault}{\sfdefault}
\fontfamily{phv}\selectfont

\linespread{1.25}

\title{Mobile Application Development}
\subtitle{Eventure Dokumentation}
\date{\today}
\author{Alexander Rasputin, Maximilian Karthan, Jona Ruof}

\begin{document}

\maketitle
\newpage
\tableofcontents

\newpage

\section{Einleitung}
\subsection{Motivation}

Um die Kenntnisse im Bereich der mobile Anwendungsentwicklung zu vertiefen,
sollte im zweiten Teil des Mobile Application Projects eine eigene Applikation
entwickelt werden. Die Anwendung sollte dabei eine Problemstellung aus einem
frei wählbaren Themengebiet lösen. Die hier entwickelte \emph{Eventure} App
vereint viele verschieden Aspekte der mobile Anwendungsentwicklung und stellt
somit eine ausreichend komplexe Aufgabe dar.

Prägend für das Design von \emph{Eventure} ist der Begriff des \emph{Events}.
Als Event wird hier jede Art des lokalen, zeitlich begrenzten, sozialen
Ereignisses verstanden. So werden z.B. eine Theatervorstellung, ein
Volleyballspiel im Park oder eine Geburtstagsfeier als Events bezeichnet. Events
bieten Möglichkeiten zur sozialen Interaktion mit Freunden und Fremden und sind
damit relevant für das Leben der aller Menschen. Gerade für ortsfremde
Personen ist es oftmal kompliziert an die relevanten Eckdaten (Zeit, Ort, etc.
 ...) eines Events zu kommen. Da keine zentralisierte Sammelstelle für solche
Information existiert, sind diese meist in verschiedensten Medien zu finden oder
werden nur von Person zu Person weitergegeben. Daher scheint die Notwendigkeit
einer Applikation für das Entdecken von Events gegeben.

Es existieren bereits einige solcher Apps, welche allerdings (subjektiv
betrachtet) nicht einfach und intuitiv genug bedient werden können. So sind
insbesondere die Abläufe für das Finden und Erstellen von Events zu kompliziert
gestaltet. Zahlreiche Einstellungs- und Suchoptionen verschlechtern die
Bedienbarkeit zusätzlich.

\subsection{Ziel}

Das Ziel des Mobile Application Developments ist die Entwicklung einer Android
Applikation die das Entdecken und Erstellen von Events ermöglicht. Dabei sollte
die App besonders einfach zu bedienen sein. Die Probleme der bereits bekannten
Event Apps sollten gelöst oder zumindest entscheidend verbessert werden.
Außerdem sollen die Kenntnisse in der Android Programmierung weiter vertieft
werden, so dass am Ende des Projekts alle grundlegenden und einige
weiterführende Konzepte der mobilen Anwendungentwicklung bekannt sind.

\subsection{Aufbau}

In der folgenden Dokumentation werden in der Anforderungsanalyse zunächst die
funktionalen und nicht funktionalen Anforderungen der Applikation präsentiert.
Ebenfalls werden verwendeten Frameworks und die Architektur des Gesamtsystems
beschrieben. Danach wird das Konzept und der Entwurf der App anhand von Mockups
erläutert. Im nächsten Abschnitt werden Details der Implementierung und
Besonderheiten der App präsentiert. Zuletzt werden die gestellten Anforderungen
mit der tatsächlichen Implementierung der App verglichen es wird festgestellt
welche Anforderungen bis zu welchem Grad erfüllt wurden.

\newpage

\section{Anforderungsanalyse}

\subsection{Funktionale Andforderungen}

\textbf{FA1 Accountmanagement}

Zur Verwendung der App wird ein Benutzeraccount benötigt. Dieser kann in der App
selbst erstellt werden. Wenn möglich, sollte auch eine OAuth Authentifizierungs
implementiert werden, die es Benutzer ermöglicht vorhandene Accounts von Google,
Facebook etc. zur Anmeldung zu verwenden. Für einen Account werden als
Informationen mindestens die E-Mail Addresse des Benutzers ein Passwort und ein
Name benötigt. Optional sollte auch ein persönliches Benutzerbild eingefügt
werden können. Es sollte außerdem möglich sein Accountdetails wie den Namen oder
das Passwort zu berabeiten oder den Account vollständig zu löschen.

\textbf{FA2 Eventmanagement}

Der Benutzer muss die Möglichkeit haben selbst eigene Events in der entwickelten
App zu erstellen. Dabei besteht ein Event aus einem Bild, einem Titel, einem
Ort, einer Startzeit, einer maximalen Anzahl an Teilnehmern, einer Kategorie und
einem optionalen Kommentar. All diese Details sollten auch nach dem Erstellen
eines Events jederzeit wieder geändert werden können. Außerdem muss der Benutzer
ein selbst erstelltes Event jederzeit löschen können. Ein Benutzer kann einem
Event beitreten, insofern die maximale Anzahl an Event-Teilnehmern noch nicht
erreicht wurde. Zu jedem Zeitpunkt kann eine Benutzer, der nicht der Ersteller
des Events ist, ein Event verlassen. Der Ersteller eines Events kann diese nur
löschen, nicht aber verlassen.

\textbf{FA3 Eventübersicht}

Um die verschiedenen Events dem Benutzer zu präsentieren muss die App eine
Übersicht über die verschiedenen Events bieten. Dabei sollte vor allem zwischen
Events an welchen der Benutzer beteiligt und an welchen der Benutzer nicht
beteiligt ist unterschieden werden.

\textbf{FA4 Filter}

Die in der Eventübersicht angezeigten Events müssen nach verschiedenen Kriteren
gefiltert werden können. So kann der Benutzer z.B. einen Suchradius für Events
konfigurieren. Alle Events, deren Entfernung zum Standort des Benutzer kleiner
als dieser Radius ist, sollen nicht gefiltert werden. Alle Events die außerhalb
des Radius liegen werden gefiltert, d.h. nicht angezeigt. Außerdem ist es
möglich die Events anhand ihrer Kategorien zu filtern.

\textbf{FA5 Gruppenchat}

Ist der Benutzer einem Event beigetreten hat dieser die Möglichkeit sich mit
anderen Teilnehmern des Events in einem Gruppenchat auszutauschen. Dabei wird
für jedes Event eine eigener Chat erstellt zu dem nur die Teilnehmer eines
Events zugelassen sind.

\textbf{FA6 Chatübersicht}

Der Benutzer hat die Möglichkeit durch eine Übersicht alle Chats anzeigen zu
lassen an welchen dieser teilnimmt. Von dieser Übersicht aus kann ein beliebiger
Chat betreten werden.

\textbf{FA7 Kartenansicht}

Der Benutzer kann sich alle momentan verfügbaren Events ein einer Kartenansicht
anzeigen lassen. Dabei wird eine Kartenstapel simuliert, wobei immer nur die
oberste Karte für den Benutzer sichtbar ist. Durch eine Wischgeste wird die
oberste Karte des Stapels entfernt und die nächste Karte sichtbar. So kann der
Benutzer nacheinander durch die verfügbaren Events blättern.

\subsection{Nicht Funktionale Andforderungen}

\textbf{NFA1 Robustheit} \newline
Das Spiel soll eine gewisse Robustheit aufweisen, also auf fehlerhafte Eingaben
oder unvorhergesehene Ereignisse angemessen reagieren. Im Falle eine Absturzes
sollte die Applikation ohne Verlust des Spielfortschritts neu gestartet werden
können.

\textbf{NFA2 Erweiterbarkeit} \newline
Die Programmstruktur der Applikation sollte derart gestaltet sein, dass
spätere Erweiterungen möglichst einfach vorgenommen werden können.

\textbf{NFA3 Responsiveness} \newline
Die Oberfläche sollte stets innerhalb einer sehr kurzen Zeit auf
Benutzereingaben reagieren. Bei längeren Wartezeiten, etwa während eines
Downloads, sollte der Benutzer permanent, durch den Einsatz von entsprechenden
GUI-Elementen, über den Fortschritt der Operation informiert werden.

\textbf{NFA4 Usability} \newline
Der Benutzer sollte die App, nach einer kurzen Einführung, durch eine intuitive
und benutzerfreundliche Oberfläche ohne weitere Anleitung bedienen können.

\newpage

\section{Architektur}

\subsection{Libraries und Frameworks}

Um einige Funktionen der Applikation nicht selbst implementieren zu müssen
wurden folgende zusätzliche Programmbibliotheken und Frameworks verwendet:

\textbf{Volley, https://github.com/google/volley} \newline
Volley ist eine Netzwerkbibliothek welche die Kommunikation mit Webservices
erheblich erleichtert. Alle requests und responses werden asynchron behandelt
und als abstrakte Objekte repräsentiert. Diverse Datenformate (wie JSON) werden
direkt in einer Objektrepräsentation ausgegeben und sind somit im Programm ohne
weitere Umwandlung zugänglich. Auch das direkte Laden von Bildern in Widgets
(z.B. ImageView) und das dazugehörige Caching wird von Volley übernommen. Volley
wurde verwendet um die Kommunikation mit dem Event-Server der Eventure App zu implementieren.

\textbf{Gson, https://github.com/google/gson} \newline
Gson ist eine Bibliothek, welche die Serialisierung und Deserialisierung von
JSON Objekten in Java Objekte implementiert. Dabei können JSON Objekte auch
direkt in Instanzen einer Java Klasse umgewandelt werden, was einen besonders
komfortablen Umgang mit JSON ermöglicht. Gson wurde verwendet um den
Austausch von JSON-Nachrichten zwischen Server und App zu erleichtern.

\textbf{CircleImageView, https://github.com/hdodenhof/CircleImageView} \newline
Diese Bibliothek beinhaltet ein modifiziertes ImageView Widget, welches statt
einem Rechteck einen Kreis als Grundfläche besitzt. Mit Hilfe von
CircleImageView wurde die Anzeige des Profilbilds in der Chatübersicht
realisiert.

\textbf{PlaceHolderView, https://github.com/janishar/PlaceHolderView} \newline
Die PlaceHolderView Bibliothek basiert auf der RecyclerView des Android
Frameworks und erweitert diese um Animationen und zusätzliche Funktionen. Mit
Hilfe diese Library wurde die Kartenansicht der Events erstellt.

\textbf{Google Location API,
https://developer.android.com/training/location/index.html} \newline
Dieses API ermöglich die Lokalisierung des Android Gerätes über die Verwendung
des eingebeauten GPS, der momentaten Funkzelle oder der verfügbaren WLAN
Netzwerke. Das Location API wurde verwendet um den Standort des Benutzer für die
Filterung der Events zu bestimmen.

\textbf{Firebase, https://firebase.google.com} \newline
Firebase ist eine online Datenbank auf JSON Basis. Die Datenbank kann durch
einfache Queries manipuliert werden und Clients können sich über Änderungen in
der Datenbank in Echtzeit informieren lassen. Firebase wurde verwendet um
den Gruppenchat der einzelnen Events zu realisieren.





%% Ab hier alte Doku




\section{Konzept und Entwurf}
\subsection{Mockups}
Vor dem eigentlichen Implementieren der App wurden Mockups erstellt. Diese
sollten einen ersten Eindruck vom User Interface geben und dienten als
Orientierung während der eigentlichen Implementierung.

An jeder beliebigen Stelle der App hat man Zugriff auf den Navigation Drawer.
Dieser ist ein Menü, welches sich von der linken Seite durch eine Wischgeste
herausziehen lässt. Abbildung ~\ref{drawer} zeigt das Konzept dieses Menüs.

Abbildung ~\ref{singleplayer1} skizziert den Prozess, welchen der Benutzer
vollführen muss, um vom Hauptmenü zum Einzelspieler Modus zu gelangen.

Nach dem das Deck ausgewählt wurde befindet sich der Spieler im eigentlichen
Einzelspieler Modus. Abbildung ~\ref{singleplayer2} skizziert das
Spielgeschehen.

Einstellungen kann der Benutzer in der Settings Activity vornehmen. Allerdings
sind die Möglichkeiten in unserer App sehr beschränkt wie Abbildung
~\ref{settings} zeigt.

Außerdem haben wir Mockups zu den Statistiken erstellt. Hier kann der Benutzer
seine bisherigen Erfolge einsehen. Diese Activity ist auf den Abbildungen
~\ref{stats1} und ~\ref{stats2} zu sehen


\clearpage

\section{Implementierung}
\subsection{Ausgewählte Implementierungsdetails}
\subsubsection{Galerie}

In der Galerie werden alle Kartendecks aufgelistet, die auf dem Smartphone
vorhanden sind oder vom Server heruntergeladen werden können. Heruntergeladenen
Decks könne durch Antippen geöffnet werden. In der geöffneten Ansicht kann der
Benutzer durch vertikale Wischgesten durch die einzelnen Karten des virtuellen
Kartenstapels blättern. Tippt der Benutzer ein Deck an, welches nicht
heruntergeladen ist, wird ein Dialog geöffnet in welchem das Herunterladen des
Decks bestätigt oder abgelehnt werden kann. Das Deck wird nicht direkt geladen,
da sich der Benutzer eventuell in einer Netzwerkumgebung befindet, in welcher
durch Downloads Kosten entstehen können. Durch den Bestätigungsdialog wird dem
Benutzer somit eine Möglichkeit gegeben den Download zu einem späteren Zeitpunkt
mit günstigeren Netzwerkbedingungen zu starten. Wird der Dialog bestätigt startet
der Download des Decks. Im Listenelement des Decks wird ein Ladebalken angezeigt
und im Notification Drawer wird eine Notification erstellt die ebenfalls den
Fortschritt des Downloads anzeigt. Nach erfolgreichem Download wird die
Notification geschlossen und der Ladebalken verschwindet wieder. Das Deck ist
dann persistent auf dem Gerät gespeichert und kann nun auch ohne
Internetverbinung angezeigt werden. Zudem können nun auch die Karten des Decks,
wie oben beschreiben angezeigt werden. Auch kann das Deck nun im Einzelspieler
Modus verwendet werden.

\ \newline
Um die Galerie mit diesen beschriebenen Funktionen zu realisieren, waren einige
besondere Implementierungsmethoden notwendig. Da den meisten Decks und Karten
relativ hochauflösende Bilder zugeordnet sind, entstehen beim Anzeigen der Decks
bzw. Karten Verzögerungen, da große Datenmengen geladen werden müssen. Dabei ist
außerdem zu erwähnen, dass das Laden der Bilder der Decks, die nicht auf dem
Gerät gespeichert sind, über das Netzwerk erfolgt und somit zusätzliche
Verzögerungen entstehen. All diese Verzögerungen sind als starke Ruckler
bemerkbar und beinträchtigen das Nutzererlebnis erheblich. Das Laden der Bilder
wurde daher auf einen zweiten Thread ausgelagert. Somit kann der Benutzer
weitere Interaktion vornehmen während im Hintergrund die Bilder nachgeladen
werden. Auch der Download eines Decks verwendet einen eigenen Thread, um
Verzögerungen im Haupt-Thread der Applikation zu vermeiden. Zusätzlich wurde
hier auch das Service Modell der Android Platform verwendet. So kann garantiert
werden, dass der Download abgeschlossen wird, auch wenn die Galerie verlassen
oder die App während des Downloads geschlossen wird. Um die heruntergeladenen
Daten in der Datenbank zu speichern war ebenfalls eine besonderer Strategie
nötig. Die Daten können nicht sofort gespeichert werden, da sonst bei Fehlern
inkonsistente Zustände in der Datenbank auftreten. Daher werden geladene Daten
zunächst im RAM gehalten bis der Download vollständig abgeschlossen ist und dann
in einer einzigen Transaktion in die Datenbank geschrieben. Somit wird immer ein
konsistenter Zustand der Datenbank erreicht und Fehler können einfacher
abgefangen werden.

\subsubsection{Einzelspieler}

\noindent
Im Einzelspielermodus der Quartett App werden vor jedem Spiel zunächst einige
Spieleinstellungen abgefragt. Der Name des Spielers wird für den Eintrag in die
lokale Rangliste verwendet. Außerdem kann der Schwierigkeitsgrad, also die
Stärke der KI, und der Spielmodus eingestellt werden. Um die Einstellungen nicht
bei jedem Spielstart erneut setzen zu müssen können Standardwerte für jeden
Parameter in den allgemeinen Spieleinstellungen hinterlegt werden. Nachdem alle
Einstellungen getroffen wurden wird der Spieler aufgefordert ein Deck
auszuwählen, mit welchem das Spiel gestartet werden soll. Dabei stehen nur Decks
zur Auswahl die bereits heruntergeladen worden sind. Nach der Auswahl eines
Decks startet das eigentliche Spiel. Dem Spieler wird eine Karte angezeigt, von
welcher ein Attribut ausgewählt werden kann. Dieses Attribut wird mit dem
Attribut verglichen, das die KI ausgewählt hat. Je nach Wert und Art des
Attributs gewinnt oder verliert der Spieler die Karte. Das Ergebnis des
Vergleichs wird in einer eigenen Ansicht präsentiert. Dort werden die beiden
Karten gegenüber gestellt und Gewinner (grün) und Verlierer (rot) entsprechend
eingefärbt. Hat der Spieler gewonnen so darf er erneut das Attribut bestimmen,
sonst wird der nächste Zug durch die KI ausgeführt. Ist schließlich die
Abbruchbedingung des Spiels erreicht (Zeit, Punkte, Runden) wird das Spiel
beendet und eine Punktezahl berechnet. War der Spieler besonders gut wird
außerdem automatisch ein Eintrag in der Rangliste vorgenommen. Danach besteht
die Möglichkeit das Spiel mit den selben Einstellungen erneut zu starten, die
Einstellungen zu ändern, oder in das Hauptmenü zurückzukehren.


\noindent
Bei der Implementierung des Einzelspielers war besonders die KI eine
Herausforderung. Diese musste sich möglichst wie ein Spieler verhalten und kein
unfaires Spielerlebnis bieten, also nicht zu viel Wissen über den Spielstatus
erhalten. Die hier verwendete Implementierung erzeugt zunächst für jedes
Attribut eine nach eben diesem Attribut sortierte Liste der Karten. Danach wird
die Position der Karte in jeder dieser Listen ermittelt und dem jeweiligen
Attribut zugeordnet. Damit weiß die KI nun welches der Attribute das
\enquote{beste}, also das mit den höchsten Gewinnchancen ist. Je nach
eingestelltem Schwierigkeitsgrad wird die KI dann eher bessere oder eher
schlechtere Attribute auswählen. So wird ein Spieler simuliert, der das
Kartendeck, je nach Schwierigkeitsgrad, mehr oder weniger gut kennt, somit
abschätzen kann wie \enquote{gut} ein Attribut ist und auf Basis dieser
Schätzung seine Entscheidungen trifft. Außerdem erhält die KI mit dieser
Implementierung auch nicht mehr Informationen als ein menschlicher Spieler.
Unfaires Verhalten wird somit verhindert.

\subsubsection{Multiplayer}
Der Multiplayer bietet den Spielern die Möglichkeit über eine Internetverbindung
gegeneinander zu spielen. Entscheidet sich der Nutzer zu einem Multiplayer Spiel
gelangt dieser zu erst auf eine Activity die ihm eine Liste aller Spiele anzeigt
die er gerade spielt und auch die Möglichkeit gibt ein neues Spiel zu starten.
Wählt der Nutzer ein neues Spiel kann er sich entscheiden ob er automatisch
einem anderen Spieler zugeteilt werden möchte oder gezielt mit einer bestimmten
Person spielen möchte.

\ \newline
Im Mulitplayer-Modus wird im Gegensatz zum herkömmlichen Quartett immer
abwechselnd gespielt egal wer die vorherige Runde gewonnen hat. Dies ist eine
Designentscheidung die aus Usability Gründen getroffen wurde. Andernfalls könnte
es vorkommen ein Spieler macht einen Zug, schließt die App um später weiter zu
spielen aber in der Zwischenzeit gewinnt sein Gegner alle folgenden runden und
beendet das Spiel ohne, dass der erste Spieler etwas mitbekommt.

\ \newline
Die technische Umsetzung wurde durch die bereits im Kapitel Libaries und
Frameworks erwähnten Google Play Services extrem erleichtert. Durch die
Verwendung dieser Services mussten wir uns nur noch um den client-seitigen Teil
der Anwendung kümmern. Hier war der anspruchsvollste Teil jedes mögliche
Szenario abzudecken. Also entsprechend zu reagieren wenn einer der Spieler einen
Zug gemacht hat und der andere zum Beispiel gerade noch das Ergebnis des
vorherigen Zuges angeschaut hat oder gar nicht mehr innerhalb der App war. Da
Quartett ein rundenbasiertes Spiel ist war die Synchronisation eher trivial.
\subsection{Architektur}
\subsubsection{Datenmodell}

\noindent
Im obigen ER Diagramm ist die Struktur unseres Datenmodells dargestellt. Zur
Realisierung wurde die in Android integrierte SQL Datenbank SQLite in
Kombination mit Sugar ORM verwendet. So konnten die einzelnen Entitäten direkt
über Klassen angesprochen werden und es mussten keine SQL Statements verwendet
werden. Allerdings beherrscht Sugar ORM in der verwendeten Version keine Listen
und Beziehungen zwischen den einzelnen Entitäten können mit Sugar ORM ebenfalls
nur schwierig oder gar nicht dargestellt werden. Die Daten der gespeicherten
Bilder wurden nicht in die SQL Datenbank geladen sondern direkt im internen
Speicher des Geräts abgelegt. Auch die \enquote{Preferences} werden nicht mit
SQL gespeichert sondern in den SharedPreferences des Android Systems abgelegt.
SharedPreferences ist eine einfach Key-Value Datenbank die sich kleine
Datenmengen eignet.

\subsubsection{Klassenstruktur}

\noindent
Um die Applikation zu strukturieren wurde hier das Model-View-Presenter Pattern
angewendet. Mit diesem Pattern wird jede Activity in Model-, View- und
Presenter- Komponenten zerlegt. Die Model Komponenten beinhalten die
Zugriffsschicht auf die Datenbank mit allen zugehörigen Klassen. In der hier
vorgestellten App wird das Model durch Sugar ORM bzw. durch dessen
Entitätsklassen dargestellt. Außerdem wird die Serveranbindung, welche durch das
Volley Framework realisiert wird, ebenfalls zum Model gezählt. Es existiert
nur ein gemeinsames Model für alle Activities. Auf das Model kann nur vom
Presenter aus zugegriffen werden. Dieser verwaltet die
eigentlich Logik einer Activity. Dabei ist der Presenter selbst eine einfache
Java Klasse ohne direktes Wissen über das Android System oder die Datenbank.
Events der View werden an den Presenter weitergeleitet und dort bearbeitet. Der
Presenter kann zur Bearbeitung von Events sowohl auf das Model als auch auf die
View Komponenten zugreifen. Diese Komponenten beinhaltet die Anzeigeschicht und
verwaltet die einzelnen GUI-Elemente. In unserer App wird die View von einer
Fragment Klasse implementiert. Direkt kommuniziert die View nur mit dem
Presenter und greift nicht auf das Model zu. In der Praxis gibt es dabei
allerdings einige Ausnahmen.

\ \newline
Um z.B. das Anzeigen von Listen in Android effizient zu realisieren werden
sogenannte Adapter verwendet. Diese greifen meist direkt auf die Datenbank zu
und stellen die erhaltenen Daten direkt in einer ListView da. Damit können diese
Klassen nicht eindeutig den Model oder View Komponenten zugeordnet werden. Daher
implementieren diese meist sowohl die Eigenschaften des Models als auch der
View.

\ \newline
Durch die klare und immer gleichförmige Strukturierung in Model, View und
Presenter, wird das Erstellen von neuen Activities vereinfacht, da somit ein
klarer Arbeitsablauf gegeben ist. Auch das lesen und editieren von fremden Code
wird erleichtert, da von vornherein anhand der Benennung der einzelnen Klassen
klar ist welche Aufgaben diese Komponenten übernehmen.

\section{Anforderungsabgleich}

Im Folgenden werden die gegebenen Anforderungen mit der tatsächlichen
Implementierung verglichen. Es wird festgestellt ob eine Anforderung ganz,
teilweise oder gar nicht erfüllt wurde.

\subsection{Funktionale Anforderungen}

\textbf{FA1 Hauptmenü - erfüllt} \newline
Das Hauptmenü wurde wie in der Anforderung beschrieben implementiert.

\ \newline
\textbf{FA2 Spielmodi - erfüllt} \newline
Alle Spielmodi wurden wie gefordert implementiert und können vor jedem Spiel
ausgewählt werden.

\ \newline
\textbf{FA3 Computergegner - erfüllt} \newline
Für den Einzelspielermodus wurde ein Computergegner implementiert, der ein
faires Spielerlebnis bietet. Diese \enquote{KI} kann je nach Schwierigkeitsgrad
unterschiedlich gut abschätzen welches Attribut einer Karte die höchsten
Gewinnchancen hat und imitiert so das Verhalten eines menschlichen Spielers.

\ \newline
\textbf{FA4 Schwierigkeitsgrad - erfüllt} \newline
Die geforderten Schwierigkeitsgrade wurden implementiert und können vor dem
Beginn eines neuen Spiels ausgewählt werden. Die Wahl des Schwierigkeitsgrads
beeinflusst das Verhalten der KI.

\ \newline
\textbf{FA5 Spiel fortsetzen - erfüllt} \newline
Nach jedem Spielzug wird der komplette Zustand des Spiels in die interne
Datenbank geschrieben und damit persistent gespeichert.

\ \newline
\textbf{FA6 Galerie - erfüllt} \newline
Die Galerie wurde wie in \enquote{Implementierungsdetails} beschreiben
implementiert.

\ \newline
\textbf{FA7 Deck Download - erfüllt} \newline
Der Deckdownload wurde wie in \enquote{Implementierungsdetails} beschreiben in
die Galerie integriert.

\ \newline
\textbf{FA8 Statistiken - erfüllt} \newline
Die Statistiken wurden implementiert und werden graphisch aufbereitet in einer
speziellen Ansicht dargestellt.

\ \newline
\textbf{FA9 Rangliste - erfüllt} \newline
Die beschriebene Rangliste wurde implementiert. Der Spieler wird mit dem Namen
der zu Beginn eines Spiels eingegeben wurde, automatisch mit seiner erreichten
Punktezahl in die Rangliste aufgenommen

\ \newline
\textbf{FA10 Achievements - teilweise erfüllt} \newline
Es wurde eine Oberfläche zur Anzeige der Achievements implementiert. Ein
fertiges Achievementsystem ist allerdings nicht in der App vorhanden.

\ \newline
\textbf{FA11 Quartetteditor - nicht erfüllt} \newline
Der Quartetteditor wurde zugunsten des Multiplayers nicht realisiert.

\ \newline
\textbf{FA12 Levelsystem - nicht erfüllt} \newline
Das Levelsystem wurde zugunsten des Multiplayers nicht realisiert

\ \newline
\textbf{FA13 Multiplayer - erfüllt} \newline
Der Multiplayer wurde mit Hilfe der Google Play Services implementiert und
erlaubt es zwei Benutzer der App über das Internet gegeneinander anzutreten.

\subsection{Nicht Funktionale Anforderungen}

\textbf{NFA1 Robustheit - teilweise} \newline
Der Multiplayer weist aufgrund der Komplexität und fehlender Entwicklungszeit
noch einige Stabilitätsprobleme auf. Ansonsten konnten während der Entwicklung
keine Fehler festgestellt werden, welche die Robustheit der App beinträchtigen.

\ \newline
\textbf{NFA2 Erweiterbarkeit - erfüllt} \newline
Durch die Verwendung des Model-View-Presenter Patterns ist eine einfache
Erweiterbarkeit gegeben.

\ \newline
\textbf{NFA3 Responsiveness - erfüllt} \newline
Durch den permanenten Einsatz von asynchronen Programmiertechniken wurde
sichergestellt, dass die Applikation immer entsprechend schnell reagiert.

\ \newline
\textbf{NFA4 Usability - erfüllt} \newline
Um die Usability sicher zu stellen wurden die Google User Interface Guidelines
als Referenz für die Gestaltung der Oberflächen verwendet.

\section{Zusammenfassung und Ausblick}

In dieser Dokumentation wurde die Planung der Entwicklung einer Android Quartett
App und die tatsächlich Implementierung dieser vorgestellt. Da die allermeisten
der funktionale und nicht funktionalen Anforderungen erfüllt wurden, kann das
Projekt als erfolgreich bewertet werden. Darüberhinaus konnten wir zahlreiche
Einblicke in die Entwicklung von Android Applikationen erhalten. Wir sind nun
mit den wichtigsten Konzepten der Plattform vertraut, sodass die Entwicklung
weiterer Apps deutlich einfacher zu bewerkstelligen sein wird. Außerdem konnten
wir zusätzliche Erkenntnisse in der Verwendung von Design Patterns und des
Versionskontrollsystems git sammeln.

\ \newline
Aufgrund der gewonnen Erkenntnisse und des allgemein guten Projektverlaufs werden
wir auch weiter Apps mit Android und unter zu Hilfenahme der hier verwendeten
Werkzeuge und Strategien entwickeln.

\end{document}
